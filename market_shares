import pandas as pd
import biogeme.database as db
import biogeme.biogeme as bio
from biogeme.biogeme import BIOGEME
from biogeme.expressions import Expression
from biogeme.expressions import Beta, Variable
from biogeme.models import loglogit, boxcox, logit
from biogeme.segmentation import DiscreteSegmentationTuple, segmented_beta
import numpy as np
from logit_lmpc_model3 import all_results, logprob_boxcox, biogeme_boxcox
from logit_lmpc_model3 import V_boxcox
from typing import NamedTuple
import pickle
from logit_lmpc12_model4 import results_nested, lognested, biogeme_nested, nests
from logit_lmpc12_model2 import V_2, logprob_2, biogeme_2, results_2
from logit_lmpc12_model1 import V_1, logprob_1, biogeme_1, results_1
from logit_lmpc12_base import V_base_normalized, logprob_base, biogeme_base, results

from typing import NamedTuple
import numpy as np
from IPython.core.display_functions import display
from matplotlib import pyplot as plt
from tqdm import tqdm

from biogeme.biogeme import BIOGEME
from biogeme.expressions import Expression
from biogeme.models import loglogit, logit

class IndicatorTuple(NamedTuple):
    """Tuple storing the value of an indicator, and the bounds on its confidence interval."""

    value: float
    lower: float
    upper: float

import pandas as pd

# Define population sizes for each stratum
census = {
    'female_44_less': 2841376,
    'female_45_more': 1519948,
    'male_44_less': 2926408,
    'male_45_more': 1379198,
}

# Total population size
population_size = sum(census.values())
print(f'Size of the population: {population_size:_}')

# Load the dataset
file_path = 'lpmc12.dat'
df = pd.read_csv(file_path, sep='\t')

# Define filters for each stratum
filters = {
    'female_44_less': (df['female'] == 1) & (df['age'] <= 44),
    'female_45_more': (df['female'] == 1) & (df['age'] > 44),
    'male_44_less': (df['female'] == 0) & (df['age'] <= 44),
    'male_45_more': (df['female'] == 0) & (df['age'] > 44),
}

# Count the sample size in each stratum
sample_segments = {
    segment_name: segment_rows.sum() for segment_name, segment_rows in filters.items()
}
print(f'Sample segments: {sample_segments}')

# Total sample size
total_sample = sum(sample_segments.values())
print(f'Sample size: {total_sample}')

# Calculate weights
weights = {
    segment_name: census[segment_name] * total_sample / (segment_size * population_size)
    for segment_name, segment_size in sample_segments.items()
}
print(f'Weights: {weights}')

# Apply weights to the dataset
df['weight'] = 0.0
for segment_name, segment_rows in filters.items():
    df.loc[segment_rows, 'weight'] = weights[segment_name]

weight = Variable('weight')

# Verify sum of weights
sum_weights = df['weight'].sum()
print(f'Sum of the weights: {sum_weights}')

# Display the first few rows of the weighted dataset
print(df.head())

def market_share(utilities: dict[int, Expression]) -> dict[str, IndicatorTuple]:
    """Calculate the market shares of all alternatives, given the
    specification of the utility functions.

    :param utilities: Specification of the utility functions. It is a
        dict where the keys are the IDs of the alternatives, and the
        values are the expressions of the utility functions.

    :return: A dictionary where each entry corresponds to an
        alternative, and associates its name with the IndicatorTuple
        containing the value of the market share, and the lower and
        upper bounds of the 90% confidence interval.
    """
    # Logit probabilities for each alternative
    prob_walk = lognested(utilities, None, nests, 1)
    prob_cycle = lognested(utilities, None, nests, 2)
    prob_pt = lognested(utilities, None, nests, 3)
    prob_car = lognested(utilities, None, nests, 4)

    # Simulation setup
    simulate = {
        'weight': weight,
        'Prob. walk': prob_walk,
        'Prob. cycle': prob_cycle,
        'Prob. PT': prob_pt,
        'Prob. car': prob_car,
    }
    database = db.Database('lpmc12', df)
    
    biosim = BIOGEME(database, simulate)
    simulated_values = biosim.simulate(results_nested.get_beta_values())

    # Sensitivity analysis for confidence intervals
    betas = biogeme_nested.free_beta_names
    b = results_nested.get_betas_for_sensitivity_analysis(betas, use_bootstrap=False)
    left, right = biosim.confidence_intervals(b, 0.9)

    # Market shares for each alternative
    market_shares = {}
    for alt_name, prob_name in [
        ("Walking", "Prob. walk"),
        ("Cycling", "Prob. cycle"),
        ("Public transportation", "Prob. PT"),
        ("Car", "Prob. car"),
    ]:
        simulated_values[f"Weighted choice_prob. {alt_name.lower()}"] = (
            simulated_values["weight"] * simulated_values[prob_name]
        )
        left[f"Weighted choice_prob. {alt_name.lower()}"] = (
            left["weight"] * left[prob_name]
        )
        right[f"Weighted choice_prob. {alt_name.lower()}"] = (
            right["weight"] * right[prob_name]
        )

        market_share_value = simulated_values[f"Weighted choice_prob. {alt_name.lower()}"].mean()
        market_share_lower = left[f"Weighted choice_prob. {alt_name.lower()}"].mean()
        market_share_upper = right[f"Weighted choice_prob. {alt_name.lower()}"].mean()

        market_shares[alt_name] = IndicatorTuple(
            value=market_share_value,
            lower=market_share_lower,
            upper=market_share_upper,
        )

    return market_shares

market_shares_base = market_share(V_boxcox)
for alternative, indicator in market_shares_base.items():
    print(
        f'Market share for {alternative}: {100*indicator.value:.1f}% '
        f'[{100*indicator.lower:.1f}%, '
        f'{100*indicator.upper:.1f}%]'
    )
